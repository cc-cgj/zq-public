

--------------------组件通信 //在组件中传递数据的方式为单向数据流

	一、父组件传递data数据给子组件

		概念：传递的数据，在子组件中修改父组件传递的数据时父组件的数据也会发生变化，但删除父组件传递的数据时父组件的数据并不会跟着发生

	改变，此时若想删除父组件传递的数据只能通过触发父组件的自定义事件来删除父组件传递的数据，而删除父组件传递的数据后，子组件接收的数据也会

	跟着删除。

		1、给组件标签设置自定义属性

			<cpt  v-bind:自定义属性名="父组件的data数据名"></cpt>

		2、在注册子组件时添加props属性,用来接收父组件传递的数据，该属性决定了组件标签中自定义属性的名称。

			Vue.component({ props:["自定义属性名1","自定义属性名2"] })

		3、调用方式：

			Vue.component({ props:"自定义属性名",data(){ return{ msg:this.自定义属性名 } } })

	二、子组件传递data数据给父组件

		1、在注册子组件时注册一个监听事件

		2、在子组件标签中添加自定义事件名，如<cpt @自定义事件="fn($event)">

		3、在子组件的事件回调函数中通过this.$emit("自定义事件名",传递的参数)来触发父组件的自定义事件，即触发子组件标签中的自定义事件
	
	的回调函数fn

		4、该回调函数在父组件的methods属性中定义，通过设置回调函数的参数来接收子组件传递的参数

		注意：

			1、注册的一个子组件使用$emit()来触发父组件的自定义事件，只能触发自己的子组件标签定义自定义事件的事件处理函数。	

			2、与 props 的命名一样，当你使用 DOM 模板时，我们建议使用 kebab-case 事件监听器。如果你使用的是字符串模板，这个限制就不适用。	

		
	三、兄弟组件传值(触发事件，通过调用兄弟组件的事件处理函数向事件中心(实例vue)发送数据（$emit）和接收数据（$on）来达到传值)

		注意：接收数据在vue的生命周期的mounted钩子函数里调用$on()方法

		例：

			<div id="#app">

				<cpt1></cpt1>

				<cpt2></cpt2>
		
			</div>

			var hub = new Vue() //事件中心

			Vue.compotents("cpt1",{

				template:`<button @click="btn1">触发1</button>`,

				methods:{ btn1(){ hub.$emit( "cpt2-event","传递给cpt2的数据" ) } },
			
				mounted(){ hub.$on( "cpt1-event",function(res){ console.log(res) } ) }

			})	

			Vue.compotents("cpt2",{

				template:`<button @click="btn2">触发2</button>`,

				methods:{ btn1(){ hub.$emit( "cpt1-event","传递给cpt1的数据" ) } },
			
				mounted(){ hub.$on( "cpt2-event",function(res){ console.log(res) } ) }

			})

			new Vue( el:"#app" )//挂载			
	
	四、$on：
		
		概念：监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。回调函数会接收所有传入事件触发函数的额外参数。

		语法：vm.$on("自定义事件名",function(n){})

		参数：
			
			n：接收传递的参数，

	五、$emit

		概念：触发当前实例上的自定义事件。附加参数都会传给监听器的回调函数。

		语法：vm.$emit("自定义事件名","传递的参数")

		注意：

			1、子传父的本质就是在子组件标签定义自定义事件，该自定义事件由子组件触发，通过$emit来将子组件的数据传递给父组件。

			2、自定义事件不是浏览器产生的事件对象,所以默认不具有浏览器的事件对象,自定义事件的事件对象为传递的参数，在调用函数时

		可以不需要加括号，此时会默认将传递的参数通过自定义事件的事件处理函数的形参接收，否则附加参数无法接收，也可以通过调用函数时在
		
		使用$event接收，注意事件处理函数也需要设置形参，自定义的事件对象数据类型是以传递的参数为准。

			3、传递的参数可以是多个，参数之间用逗号隔开

			4、$emit()传递的参数赋值给触发事件的回调函数的形参具有一一对应的关系。 

		/** vue3.x */

		对象语法：

			export default {
  
				emits: {
    
					// 没有验证函数
    
					click: null,

    					// 具有验证函数
    
					submit: (payload) => {
      
						if (payload.email && payload.password) {
        
							return true
      
						} else {
        
							console.warn(`Invalid submit event payload!`)
        
							return false
      						}
    					}
  				}
			}


	六、$off

		概念：移除自定义事件监听器。

		语法：vm.$off( "自定义事件名","监听器的回调函数" )

		注意：

			1、如果没有提供参数，则移除所有的自定义事件监听器；

			2、如果只提供了自定义事件，则移除该事件所有的监听器；

			3、如果同时提供了自定义事件与回调，则只移除这个回调的监听器。

	七、$once

		概念：监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。

		语法：vm.$on( "自定义事件名",function( n ){  } )

		参数：
			
			n：接收传递的参数

	八、vue 中this.$on为什么要放在created中？

		例：a是现在的组件，b是即将显示的组件

			两个组件的生命周期执行顺序：

				1、先执行a的creted、再执行b的creted

				2、再执行a的mouted、再执行b的mouted	

